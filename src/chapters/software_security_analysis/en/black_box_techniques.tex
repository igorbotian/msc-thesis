\Paragraph{Concept}
%
Only binary code is needed to perform black box software security testing. 
%
In the case of this type of testing, software is considered as a whole one. 
%
It responds to input data by performing predefined operations and returning appropriate output data. 
%
The principle of the testing is based on compliance between input and output data from security point of view, subject to changing of software environment \Reference{Winograd2008}. 

\Paragraph{Advantages}
%
Black box security testing has a number of advantages \Reference{Sutton2007}. 
%
The main advantage is availability because the testing can be performed irrespective of presence of tested software source code. 
%
Another advantage is repeatability of the testing because it considers tested software as a whole one regardless of it's inner mechanisms. 
%
Finally, the testing is characterized by simplicity because it does not require knowledge about implementation details that can be complex sufficiently. 

\Paragraph{Disadvantages}
%
On the other hand, black box software security testing has also a number of disadvantages \Reference{Sutton2007}. 
%
The main disadvantage is complication of the testing quality assessment. 
%
Another disadvantage is complexity of complex attacks modeling, targeted to \A specific vulnerability. 

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Fuzz-testing}{software_security_analysis_black_box_techniques_fuzz_testing}

\Paragraph{Description}
%
Fuzz-testing consists in random invalid data transmission to \A tested application through it's entry points by the use of software environment or third-party components, and the results are verified afterwards \Reference{Winograd2008}. 
%
Generated input data is usually based on alteration of valid input data. 
%
Data tranmission is performed by executing a special application called fuzzer. 
%
Usually every fuzzer is related to a specific way of data transmission, for example, by the use of HTTP protocol. 

\Paragraph{Fuzz-testing methods}
%
There are several variations of methods that are used to perform fuzz-testing \Reference{Sutton2007}. 
%
While writing test scenarios with predefined data, boundary values can be used in data structures, packets, or messages that are input data for tested software. 
%
On the other hand, randomly generated data can be used, it is effective enough but resource-intensive. 
%
There is a subkind of this type of testing, brute force, that performs examination of all options. 
%
Finally, in some cases a whole framework can be used. 
%
It analyzes output data of tested software and determines next values of input data depending on the output data. 

\Paragraph{Advantages and disadvantages}
%
Fuzz-testing has a number of limitations related to specific vulnerability type that can be found using the testing \Reference{Sutton2007}. 
%
These vulnerabilities are defects related to an access control mechanism, logical and architectural errors, backdoor search, memory corruption, as well as complex vulnerabilities that are exposed by performing multistage complex attacks. 
%
The main disadvantage is requirement of appropriate fuzzer implementing or search of existing one. 
%
Moreover, in the second case, setup of the fuzzer is needed. 
%
Therefore it can be said that it is neccesary to have deep knowledge about tested software \Reference{Winograd2008}. 

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Binary code fault injection}{software_security_analysis_black_box_techniques_fault_injection}

\Paragraph{Description}
%
The method is most widely used in combination with penetration testing to realize better how a tested application operates under attack \Reference{Goertzel2007}. 
%
The testing consists in asset alteration of tested software in a way that simulates aftermath of attack on the software. 
%
The goal of the fault injection is to examine state, behavior, and characteristics of tested software security under such circumstances \Reference{Winograd2008}. 
%
Fault injection gives the following benefits \Reference{Winograd2008}:
\begin{itemize}
	\leftskip2em%
	\setlength{\itemsep}{0pt}%
	\setlength{\parsep}{0pt}%

	\item possibility of environment anomalies simulation without understanding of the fact how they can be exposed afterwards
	\item possibility of selection which anomalies are simaluting in \A specific test without setup of entire testing environment
	\item ease of automation
\end{itemize}

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Reverse engineering}{software_security_analysis_black_box_techniques_reverse_engineering}

\Paragraph{What is reverse engineering}
%
The method comprises executing code analysis and can be used to find security vulnerabilities. 
%
In this case, a tester is playing the role of an intruder and performs tested software analysis by the means of various special tools. 
%
It allows to assess tested software security from outside and find security vulnerabilities visible from this point of view \Reference{Goertzel2007}. 
%
There is a lot of various tools used to perform this operation \Reference{Eilam2005}. 
%
Eeach of them is aimed to perform certain actions (debugging, for instance). 
%
Therefore a set of tools is selected depending on tested software. 

\Paragraph{Disassemblers}
%
Disassemblers are most widely used tools that are utilized to perform reverse engineering. 
%
They decode binary code to text to make it human-readable. 
%
The most well-known disassemblers are \IT{IDA Pro} \WebSite{IDAPro} and \IT{ILDasm} \WebSite{ILDasm}. 
%
\IT{IDA Pro} allows to carry out of x86-instruction disassembling, and \IT{ILDasm} allows to carry out .NET \WebSite{dotNet} bytecode disassembling. 

\Paragraph{Debuggers}
%
Unlike disassemblers, debuggers can be used to perform step-by-step execution of tested software. 
%
They give a chance of retrieveing of information about current application state in every moment. 
%
Also they can be used to alter workflow of tested software. 
%
The most well-known debuggers are \IT{OllyDbg} \WebSite{OllyDbg} and \IT{WinDbg} \WebSite{WinDbg}. 

\Paragraph{Decompilers}
%
Decompilers are tools that have ability to decode compiled binary code back to source code. 
%
At this moment such kind of operation can be performed only particularly because a lot of information contained in source code is not used during compile time. 
%
Moreover, the information is not remained in compiled code. 
%
The most well-known debugging tool is \IT{.NET Reflector} \WebSite{dotNETReflector}. 

\Paragraph{System monitoring tools}
%
While performing reverse engineering, system monitoring tools are often used. 
%
They allow to get a lot of information about interaction between a tested software and it's software environment. 
%
For example, they can let to know which system functions are called or which files are accessed by a tested software. 
%
The most well-known sets of such kind of tools are the following. 
%
Tools provided by SysInternals \WebSite{SysInternals} are the most popular on Windows platform \WebSite{Windows}. 
%
A different sets of tools, such as \IT{ps}, \IT{lsof}, and others, can be used on other platforms \Reference{Chess2010}. 

\Paragraph{Reverse engineering disadvantages}
%
Reverse engineering, like any other security testing method, has a number of disadvantages \Reference{Chess2007}. 
%
The main disadvantage is complexity of executing code decoding and analysis. 
%
Additional complications consists in the fact that it is necessary for a specialist to know the basics of working with various tools. 
%
Also, as it was noted above, composition of used tools can differ completely depending on testing software. 

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Black box debugging}{software_security_analysis_black_box_techniques_black_box_debugging}

\Paragraph{Description}
%
Black box debugging consists of the following activitites \Reference{Winograd2008}.
%
Initially, tested software is divided by parts. 
%
Then each part is tested individually. 
%
The goal of the black box testing is to find vulnerable parts of a tested software. 
%
Especially the method is useful when third-party closed source components are used by a tested software. 

\Paragraph{What is black box testing}
%
Black box testing is aimed to gather debug information about interaction of a tested software with it's third-party components and software environment. 
%
It is achieved by monitoring of external behaviour of tested software or it's part. 
%
By using this technique, a set of vulnerabilities, such as error skipping, can be found and eliminated \Reference{Whittaker2003}. 

\Paragraph{Tools}
%
Performing black box debugging implies utilization of appropriate tools. 
%
Gathering of debug information about tested software can be performed, for example, by file system monitoring. 
%
The most well-known tools that support such functionality are \IT{IDA Pro} \WebSite{IDAPro}, \IT{OllyDbg} \WebSite{OllyDbg}, and tools provided by SysInternals \WebSite{SysInternals}. 

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Vulnerability scanning}{software_security_analysis_black_box_techniques_vulnerability_scanning}

\Paragraph{Description}
Automatic vulnerability scanning is one of the most useful ways of software security testing and is performed by the means of appropriate tools. 
%
\The principle of work of such kind of tools is that they interact with testing environment by passing of template data, called signature \Reference{Winograd2008}. 
%
Each vulnerability scanner contains a lot of such signatures, and each of them is related to specified type of security vulnerability. 

\Paragraph{When is it the most useful}
%
Utilization of vulnerability scanners is the most effective during security analysis of third-party components before the moment of their real usage by tested software \Reference{Winograd2008}. 
%
Also, it is the most useful when it is performed before stage of penetration testing to decrease a number of testing scenarios \Reference{Winograd2008}. 

\Paragraph{Disadvantages}
%
Utilization of such kind of tools has a number of disadvantages \Reference{Winograd2008}. 
%
Usually a vulnerability scanner is able to find only 30 \% of all types of vulnerabilities. 
%
Since efficiency of a vulnerability scanner depends on a number of signatures in it's signature database, it is necessary to update the database periodically. 

\Paragraph{Tools}
%
Vulnerability scanners are divided by several categories depending on a way they interact with tested software. 
%
These categories are port scanners, web application vulnerability scanners, CGI scanners and others. 
%
The most well-known tools are \IT{Nmap} \WebSite{Nmap}, \IT{Nessus} \WebSite{Nessus}, \IT{ITS4} \WebSite{ITS4}, and others. 

% ------------------------------------------------------------------------------------------------

\SubSubSectionTitle{Penetration testing}{software_security_analysis_black_box_techniques_penetration_testing}

\Paragraph{Description}
%
Penetration testing is one of the most widely used software security methods. 
%
It performes on last software development stages and consist in analysis of tested software behaviour under attack \Reference{Arkin2005}. 

\Paragraph{Characteristics}
%
Penetration testing has a number of characteristics \Reference{Winograd2008}. 
%
While performing of the testing, tested software is executin in normal mode, without establishment of appropriate testing environment. 
%
Penetration testing as opposed to other testing methods is also directed to search of architectural and design errors. 
%
Finally, penetration testing scenarios take into consideration the worst cases that can damage tested software greatly. 

\Paragraph{The way it is performed}
%
The testing process is usually consists of the following steps \Reference{Thompson2005}. 
%
The first step is assessment of security risks, such as denial of service, information disclosure, data corruption, and others. 
%
The second step is testing planning: which components should be analyzed, how the testing should be performed, and so on. 
%
The next steps are tests running and working out of report about found security vulnerabilities. 

\Paragraph{Disadvantages}
%
By-turn, penetration testing has a number of disadvantages \Reference{Winograd2008}. 
%
The main disadvantage is the fact that it is performed on late software development stages. 
%
Therefore found security vulnerabilities may require significant costs for their elimination. 